<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Royale: royale::Vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="royale-logo-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Royale
   </div>
   <div id="projectbrief">powerful software framework for time-of-flight cameras</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceroyale.html">royale</a></li><li class="navelem"><a class="el" href="classroyale_1_1_vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classroyale_1_1_vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">royale::Vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_vector_8hpp_source.html">Vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8a596916cab061cf6d213d73c5dc1468"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classroyale_1_1royale__iterator.html">royale_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a8a596916cab061cf6d213d73c5dc1468">iterator</a></td></tr>
<tr class="memdesc:a8a596916cab061cf6d213d73c5dc1468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator definitions.  <a href="#a8a596916cab061cf6d213d73c5dc1468">More...</a><br /></td></tr>
<tr class="separator:a8a596916cab061cf6d213d73c5dc1468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b24e32345710c4c256a7833bf891ee8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classroyale_1_1royale__const__iterator.html">royale_const_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a></td></tr>
<tr class="separator:a5b24e32345710c4c256a7833bf891ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef5677686026df4b7feb0c852e3c8c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classroyale_1_1royale__reverse__iterator.html">royale_reverse_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#aeef5677686026df4b7feb0c852e3c8c2">reverse_iterator</a></td></tr>
<tr class="separator:aeef5677686026df4b7feb0c852e3c8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08019bf60c531808d5bc913bdea13ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classroyale_1_1royale__const__reverse__iterator.html">royale_const_reverse_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a></td></tr>
<tr class="separator:ae08019bf60c531808d5bc913bdea13ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac80f0477577f681b5b89b3f9609340e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#ac80f0477577f681b5b89b3f9609340e9">Vector</a> ()</td></tr>
<tr class="memdesc:ac80f0477577f681b5b89b3f9609340e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">General constructor, which does not allocate memory and sets everything to it's default.  <a href="#ac80f0477577f681b5b89b3f9609340e9">More...</a><br /></td></tr>
<tr class="separator:ac80f0477577f681b5b89b3f9609340e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8e453e6f05088a4110c1b037dddeb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a2d8e453e6f05088a4110c1b037dddeb0">Vector</a> (size_t allocationSize)</td></tr>
<tr class="memdesc:a2d8e453e6f05088a4110c1b037dddeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which already performs an allocation of memory during execution.  <a href="#a2d8e453e6f05088a4110c1b037dddeb0">More...</a><br /></td></tr>
<tr class="separator:a2d8e453e6f05088a4110c1b037dddeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62308fb469ae0f131bd84e8a414d4670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a62308fb469ae0f131bd84e8a414d4670">Vector</a> (const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a62308fb469ae0f131bd84e8a414d4670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-Constructor for royale compliant vector which allows creation of a royale compliant vector from another royale compliant vector - (NOTE: performs a deep copy!)  <a href="#a62308fb469ae0f131bd84e8a414d4670">More...</a><br /></td></tr>
<tr class="separator:a62308fb469ae0f131bd84e8a414d4670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ac272a9576eb1550b489380294330c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a42ac272a9576eb1550b489380294330c">Vector</a> (<a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;&amp;v)</td></tr>
<tr class="memdesc:a42ac272a9576eb1550b489380294330c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-Constructor for royale compliant vector which allows creation of a royale compliant vector by moving memory (NOTE: performs a shallow copy!)  <a href="#a42ac272a9576eb1550b489380294330c">More...</a><br /></td></tr>
<tr class="separator:a42ac272a9576eb1550b489380294330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779e7fda288a902cf2f3224115fd7624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a779e7fda288a902cf2f3224115fd7624">Vector</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a779e7fda288a902cf2f3224115fd7624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-Constructor for STL compliant vector (std::vector) It allows creation of a royale compliant vector from a STL compliant vector - (NOTE: performs a deep copy!)  <a href="#a779e7fda288a902cf2f3224115fd7624">More...</a><br /></td></tr>
<tr class="separator:a779e7fda288a902cf2f3224115fd7624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3">Vector</a> (const std::initializer_list&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list initialization to initialize a vector.  <a href="#ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3">More...</a><br /></td></tr>
<tr class="separator:ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f6e58246c226d67ad4337f2291e81b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#ac3f6e58246c226d67ad4337f2291e81b">~Vector</a> ()</td></tr>
<tr class="memdesc:ac3f6e58246c226d67ad4337f2291e81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ac3f6e58246c226d67ad4337f2291e81b">More...</a><br /></td></tr>
<tr class="separator:ac3f6e58246c226d67ad4337f2291e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca30cb729aa167dbaef001172b05f7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a0ca30cb729aa167dbaef001172b05f7c">size</a> () const </td></tr>
<tr class="memdesc:a0ca30cb729aa167dbaef001172b05f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size of the vector (this is the used amount of slots in the allocated area)  <a href="#a0ca30cb729aa167dbaef001172b05f7c">More...</a><br /></td></tr>
<tr class="separator:a0ca30cb729aa167dbaef001172b05f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f55e8aa9b70d115a25f9627e4c64a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a348f55e8aa9b70d115a25f9627e4c64a">empty</a> () const </td></tr>
<tr class="memdesc:a348f55e8aa9b70d115a25f9627e4c64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vector is empty.  <a href="#a348f55e8aa9b70d115a25f9627e4c64a">More...</a><br /></td></tr>
<tr class="separator:a348f55e8aa9b70d115a25f9627e4c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf5f7e6860d6f6a720e40df40253622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#afdf5f7e6860d6f6a720e40df40253622">capacity</a> () const </td></tr>
<tr class="memdesc:afdf5f7e6860d6f6a720e40df40253622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of allocated slots which are maintained by the vector These allocated slots might be used or unused (refer to <a class="el" href="classroyale_1_1_vector.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) ...">size()</a> for checking the <a class="el" href="classroyale_1_1_vector.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) ...">size()</a> itself)  <a href="#afdf5f7e6860d6f6a720e40df40253622">More...</a><br /></td></tr>
<tr class="separator:afdf5f7e6860d6f6a720e40df40253622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18917eb9ec72f0e745c332a8de2c4b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#ad18917eb9ec72f0e745c332a8de2c4b7">data</a> ()</td></tr>
<tr class="memdesc:ad18917eb9ec72f0e745c332a8de2c4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direct pointer to the memory array used internally by the vector to store its owned elements.  <a href="#ad18917eb9ec72f0e745c332a8de2c4b7">More...</a><br /></td></tr>
<tr class="separator:ad18917eb9ec72f0e745c332a8de2c4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8daf6e8b4b66202dddaf7def6702be5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#af8daf6e8b4b66202dddaf7def6702be5">data</a> () const </td></tr>
<tr class="memdesc:af8daf6e8b4b66202dddaf7def6702be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direct pointer to the memory array used internally by the vector to store its owned elements.  <a href="#af8daf6e8b4b66202dddaf7def6702be5">More...</a><br /></td></tr>
<tr class="separator:af8daf6e8b4b66202dddaf7def6702be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eb5ad97c226385781f6e43bb1c8dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a72eb5ad97c226385781f6e43bb1c8dda">front</a> ()</td></tr>
<tr class="memdesc:a72eb5ad97c226385781f6e43bb1c8dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the vector.  <a href="#a72eb5ad97c226385781f6e43bb1c8dda">More...</a><br /></td></tr>
<tr class="separator:a72eb5ad97c226385781f6e43bb1c8dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708ec6197c4dbffc97d878960deb771e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a708ec6197c4dbffc97d878960deb771e">front</a> () const </td></tr>
<tr class="separator:a708ec6197c4dbffc97d878960deb771e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bddf7264df486e69edfeda2445dde4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a8a596916cab061cf6d213d73c5dc1468">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a92bddf7264df486e69edfeda2445dde4">begin</a> ()</td></tr>
<tr class="memdesc:a92bddf7264df486e69edfeda2445dde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first position Calling this function on an empty vector will result in undefined behavior.  <a href="#a92bddf7264df486e69edfeda2445dde4">More...</a><br /></td></tr>
<tr class="separator:a92bddf7264df486e69edfeda2445dde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace268dee9b50d0f67f4c75b7f0898408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#ace268dee9b50d0f67f4c75b7f0898408">begin</a> () const </td></tr>
<tr class="separator:ace268dee9b50d0f67f4c75b7f0898408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ca430cc9d6c00571e6355aae1a337e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a8a596916cab061cf6d213d73c5dc1468">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a56ca430cc9d6c00571e6355aae1a337e">end</a> ()</td></tr>
<tr class="memdesc:a56ca430cc9d6c00571e6355aae1a337e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the last position Calling this function on an empty vector will result in undefined behavior.  <a href="#a56ca430cc9d6c00571e6355aae1a337e">More...</a><br /></td></tr>
<tr class="separator:a56ca430cc9d6c00571e6355aae1a337e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42c6e55d734794956ed3eca08faaaa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#ae42c6e55d734794956ed3eca08faaaa4">end</a> () const </td></tr>
<tr class="separator:ae42c6e55d734794956ed3eca08faaaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31263df515e507529c03067fda24b629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#aeef5677686026df4b7feb0c852e3c8c2">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a31263df515e507529c03067fda24b629">rbegin</a> ()</td></tr>
<tr class="memdesc:a31263df515e507529c03067fda24b629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the last position (reverse begin) Calling this function on an empty vector will result in undefined behavior.  <a href="#a31263df515e507529c03067fda24b629">More...</a><br /></td></tr>
<tr class="separator:a31263df515e507529c03067fda24b629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e4eee976007d9511da7b802c9d9e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a88e4eee976007d9511da7b802c9d9e73">rbegin</a> () const </td></tr>
<tr class="separator:a88e4eee976007d9511da7b802c9d9e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038207d9daef6291aa1b89a21fc1f5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#aeef5677686026df4b7feb0c852e3c8c2">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a038207d9daef6291aa1b89a21fc1f5b0">rend</a> ()</td></tr>
<tr class="memdesc:a038207d9daef6291aa1b89a21fc1f5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the last position (reverse end) Calling this function on an empty vector will result in undefined behavior.  <a href="#a038207d9daef6291aa1b89a21fc1f5b0">More...</a><br /></td></tr>
<tr class="separator:a038207d9daef6291aa1b89a21fc1f5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a026a5614b9e50f7389474bbb78a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a42a026a5614b9e50f7389474bbb78a64">rend</a> () const </td></tr>
<tr class="separator:a42a026a5614b9e50f7389474bbb78a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1e2d034e48e5ea8ac86c498fc20ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#aed1e2d034e48e5ea8ac86c498fc20ce4">cbegin</a> ()</td></tr>
<tr class="memdesc:aed1e2d034e48e5ea8ac86c498fc20ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant iterator to the first position Calling this function on an empty vector will result in undefined behavior.  <a href="#aed1e2d034e48e5ea8ac86c498fc20ce4">More...</a><br /></td></tr>
<tr class="separator:aed1e2d034e48e5ea8ac86c498fc20ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d11c4b8def6372d0efea72681f34f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a55d11c4b8def6372d0efea72681f34f1">cbegin</a> () const </td></tr>
<tr class="separator:a55d11c4b8def6372d0efea72681f34f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f782df7f2729e55faa766dab600132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a21f782df7f2729e55faa766dab600132">cend</a> ()</td></tr>
<tr class="memdesc:a21f782df7f2729e55faa766dab600132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant iterator to the last position Calling this function on an empty vector will result in undefined behavior.  <a href="#a21f782df7f2729e55faa766dab600132">More...</a><br /></td></tr>
<tr class="separator:a21f782df7f2729e55faa766dab600132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0972ea1fa7ae1d9765375e25f53932fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a0972ea1fa7ae1d9765375e25f53932fb">cend</a> () const </td></tr>
<tr class="separator:a0972ea1fa7ae1d9765375e25f53932fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bac72044686387ea348da7e5ed5375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a33bac72044686387ea348da7e5ed5375">crbegin</a> ()</td></tr>
<tr class="memdesc:a33bac72044686387ea348da7e5ed5375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the first position Calling this function on an empty vector will result in undefined behavior.  <a href="#a33bac72044686387ea348da7e5ed5375">More...</a><br /></td></tr>
<tr class="separator:a33bac72044686387ea348da7e5ed5375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803b49472e62da18aff85ff6756dc1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a803b49472e62da18aff85ff6756dc1d4">crbegin</a> () const </td></tr>
<tr class="separator:a803b49472e62da18aff85ff6756dc1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1075404e7f466d6a883797a274808c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#aae1075404e7f466d6a883797a274808c">crend</a> ()</td></tr>
<tr class="memdesc:aae1075404e7f466d6a883797a274808c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the last position Calling this function on an empty vector will result in undefined behavior.  <a href="#aae1075404e7f466d6a883797a274808c">More...</a><br /></td></tr>
<tr class="separator:aae1075404e7f466d6a883797a274808c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b35e52427d16dc89b367837f459990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a64b35e52427d16dc89b367837f459990">crend</a> () const </td></tr>
<tr class="separator:a64b35e52427d16dc89b367837f459990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7c16f12392d8d91b61442aec162b24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a7e7c16f12392d8d91b61442aec162b24">back</a> ()</td></tr>
<tr class="memdesc:a7e7c16f12392d8d91b61442aec162b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the vector.  <a href="#a7e7c16f12392d8d91b61442aec162b24">More...</a><br /></td></tr>
<tr class="separator:a7e7c16f12392d8d91b61442aec162b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc26ee0d9b58722fa9b80741c9dcdc7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#acc26ee0d9b58722fa9b80741c9dcdc7f">back</a> () const </td></tr>
<tr class="separator:acc26ee0d9b58722fa9b80741c9dcdc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403bf1a12bfa57caaca6fb6ac264ac8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a403bf1a12bfa57caaca6fb6ac264ac8c">push_back</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a403bf1a12bfa57caaca6fb6ac264ac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the vector, after its current last element.  <a href="#a403bf1a12bfa57caaca6fb6ac264ac8c">More...</a><br /></td></tr>
<tr class="separator:a403bf1a12bfa57caaca6fb6ac264ac8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dc4131f24750c21979d206f9522f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a70dc4131f24750c21979d206f9522f86">push_back</a> (T &amp;&amp;v)</td></tr>
<tr class="separator:a70dc4131f24750c21979d206f9522f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64296e90d410f55a820ed7b7c4f68bcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a64296e90d410f55a820ed7b7c4f68bcb">pop_back</a> ()</td></tr>
<tr class="memdesc:a64296e90d410f55a820ed7b7c4f68bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element in the vector, effectively reducing the container size by one.  <a href="#a64296e90d410f55a820ed7b7c4f68bcb">More...</a><br /></td></tr>
<tr class="separator:a64296e90d410f55a820ed7b7c4f68bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4721e4713d96ef69d4e1dd5e0192f47a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a4721e4713d96ef69d4e1dd5e0192f47a">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:a4721e4713d96ef69d4e1dd5e0192f47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at position index in the vector container.  <a href="#a4721e4713d96ef69d4e1dd5e0192f47a">More...</a><br /></td></tr>
<tr class="separator:a4721e4713d96ef69d4e1dd5e0192f47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d0189122c4699e72f31b117bfa4d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a68d0189122c4699e72f31b117bfa4d9e">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:a68d0189122c4699e72f31b117bfa4d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at position index in the vector container.  <a href="#a68d0189122c4699e72f31b117bfa4d9e">More...</a><br /></td></tr>
<tr class="separator:a68d0189122c4699e72f31b117bfa4d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b07fd1643df83eae61eed42a053016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a43b07fd1643df83eae61eed42a053016">at</a> (size_t index)</td></tr>
<tr class="memdesc:a43b07fd1643df83eae61eed42a053016"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function automatically checks whether index is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size).  <a href="#a43b07fd1643df83eae61eed42a053016">More...</a><br /></td></tr>
<tr class="separator:a43b07fd1643df83eae61eed42a053016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44a39385f349384309bab89c3a031f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a9b44a39385f349384309bab89c3a031f">at</a> (size_t index) const </td></tr>
<tr class="memdesc:a9b44a39385f349384309bab89c3a031f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function automatically checks whether index is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size).  <a href="#a9b44a39385f349384309bab89c3a031f">More...</a><br /></td></tr>
<tr class="separator:a9b44a39385f349384309bab89c3a031f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4a4d505cf88fbad9cbc75885dcc515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a3c4a4d505cf88fbad9cbc75885dcc515">operator=</a> (<a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; v)</td></tr>
<tr class="memdesc:a3c4a4d505cf88fbad9cbc75885dcc515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign another royale compliant vector.  <a href="#a3c4a4d505cf88fbad9cbc75885dcc515">More...</a><br /></td></tr>
<tr class="separator:a3c4a4d505cf88fbad9cbc75885dcc515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a7c5966f867acffb3ee9d942758908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#ad6a7c5966f867acffb3ee9d942758908">operator=</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ad6a7c5966f867acffb3ee9d942758908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the contents of an STL compliant vector container by replacing container's current contents if necessary and modifying its size accordingly.  <a href="#ad6a7c5966f867acffb3ee9d942758908">More...</a><br /></td></tr>
<tr class="separator:ad6a7c5966f867acffb3ee9d942758908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220abd9565189aae49fc449f0fa2ee73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a220abd9565189aae49fc449f0fa2ee73">operator==</a> (const std::vector&lt; T &gt; &amp;v) const </td></tr>
<tr class="memdesc:a220abd9565189aae49fc449f0fa2ee73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with an STL compliant vector.  <a href="#a220abd9565189aae49fc449f0fa2ee73">More...</a><br /></td></tr>
<tr class="separator:a220abd9565189aae49fc449f0fa2ee73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d4191326fbe77e022e9fad469e6d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a71d4191326fbe77e022e9fad469e6d1e">operator==</a> (const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;v) const </td></tr>
<tr class="memdesc:a71d4191326fbe77e022e9fad469e6d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with a royale compliant vector.  <a href="#a71d4191326fbe77e022e9fad469e6d1e">More...</a><br /></td></tr>
<tr class="separator:a71d4191326fbe77e022e9fad469e6d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f71c374f40d768bc975e7aada249dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a41f71c374f40d768bc975e7aada249dd">operator!=</a> (const std::vector&lt; T &gt; &amp;v) const </td></tr>
<tr class="memdesc:a41f71c374f40d768bc975e7aada249dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with an STL compliant vector.  <a href="#a41f71c374f40d768bc975e7aada249dd">More...</a><br /></td></tr>
<tr class="separator:a41f71c374f40d768bc975e7aada249dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebe10418ee8d246952511d3c15c531a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a4ebe10418ee8d246952511d3c15c531a">operator!=</a> (const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;v) const </td></tr>
<tr class="memdesc:a4ebe10418ee8d246952511d3c15c531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with a royale compliant vector.  <a href="#a4ebe10418ee8d246952511d3c15c531a">More...</a><br /></td></tr>
<tr class="separator:a4ebe10418ee8d246952511d3c15c531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0654a312b257565b4316e31828d03449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a0654a312b257565b4316e31828d03449">clear</a> ()</td></tr>
<tr class="memdesc:a0654a312b257565b4316e31828d03449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.  <a href="#a0654a312b257565b4316e31828d03449">More...</a><br /></td></tr>
<tr class="separator:a0654a312b257565b4316e31828d03449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc38c00d347551fe1ccd60459561a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a5cc38c00d347551fe1ccd60459561a30">resize</a> (size_t newSize)</td></tr>
<tr class="memdesc:a5cc38c00d347551fe1ccd60459561a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the vector to the given allocation size and initializes the elements (it may shrink)  <a href="#a5cc38c00d347551fe1ccd60459561a30">More...</a><br /></td></tr>
<tr class="separator:a5cc38c00d347551fe1ccd60459561a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04aba67806bc5797abd769f83852ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#aa04aba67806bc5797abd769f83852ec9">resize</a> (size_t newSize, T initVal)</td></tr>
<tr class="memdesc:aa04aba67806bc5797abd769f83852ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the vector to the given allocation size and initializes the elements (it may shrink)  <a href="#aa04aba67806bc5797abd769f83852ec9">More...</a><br /></td></tr>
<tr class="separator:aa04aba67806bc5797abd769f83852ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa202553f2fd8c7b4968838d605b15c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#afa202553f2fd8c7b4968838d605b15c3">reserve</a> (size_t <a class="el" href="classroyale_1_1_vector.html#a0ca30cb729aa167dbaef001172b05f7c">size</a>)</td></tr>
<tr class="memdesc:afa202553f2fd8c7b4968838d605b15c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the vector to a higher allocation size and allocates the buffers.  <a href="#afa202553f2fd8c7b4968838d605b15c3">More...</a><br /></td></tr>
<tr class="separator:afa202553f2fd8c7b4968838d605b15c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66b9ed5d416b805718ad244ef1f966c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#af66b9ed5d416b805718ad244ef1f966c">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:af66b9ed5d416b805718ad244ef1f966c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the vector's allocation to it's size Changes the size of the allocated buffer to the vector's size this may result in freeing unneeded memory allocation.  <a href="#af66b9ed5d416b805718ad244ef1f966c">More...</a><br /></td></tr>
<tr class="separator:af66b9ed5d416b805718ad244ef1f966c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b04e76ec22e187d5e1faeddd41357c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a93b04e76ec22e187d5e1faeddd41357c">toStdVector</a> ()</td></tr>
<tr class="memdesc:a93b04e76ec22e187d5e1faeddd41357c"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::vector which might be used outside the library by the application for further processing.  <a href="#a93b04e76ec22e187d5e1faeddd41357c">More...</a><br /></td></tr>
<tr class="separator:a93b04e76ec22e187d5e1faeddd41357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d1fdfdf6bb3cfd30b00a1b69912e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a11d1fdfdf6bb3cfd30b00a1b69912e13">toStdVector</a> () const </td></tr>
<tr class="separator:a11d1fdfdf6bb3cfd30b00a1b69912e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c74beaac3d5b8664b2dbb450dd3e7aa"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a2c74beaac3d5b8664b2dbb450dd3e7aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::map&lt; X, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a2c74beaac3d5b8664b2dbb450dd3e7aa">toStdMap</a> ()</td></tr>
<tr class="memdesc:a2c74beaac3d5b8664b2dbb450dd3e7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::map which might be used outside the library by the application for further processing.  <a href="#a2c74beaac3d5b8664b2dbb450dd3e7aa">More...</a><br /></td></tr>
<tr class="separator:a2c74beaac3d5b8664b2dbb450dd3e7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a153434ad7ad0df07ace7eec3bb31893b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a153434ad7ad0df07ace7eec3bb31893b">fromStdVector</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a153434ad7ad0df07ace7eec3bb31893b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given std::vector (STL) to the vector type used by the royale API.  <a href="#a153434ad7ad0df07ace7eec3bb31893b">More...</a><br /></td></tr>
<tr class="separator:a153434ad7ad0df07ace7eec3bb31893b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d172e72be02b44ec2d96b8e63d6b4d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a4d172e72be02b44ec2d96b8e63d6b4d6">toStdVector</a> (const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a4d172e72be02b44ec2d96b8e63d6b4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::vector which might be used if the royale compliant <a class="el" href="classroyale_1_1_vector.html">Vector</a> is a const.  <a href="#a4d172e72be02b44ec2d96b8e63d6b4d6">More...</a><br /></td></tr>
<tr class="separator:a4d172e72be02b44ec2d96b8e63d6b4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59784d96b6c1bf49512e808aeb992a07"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a59784d96b6c1bf49512e808aeb992a07"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; <a class="el" href="classroyale_1_1_pair.html">Pair</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a59784d96b6c1bf49512e808aeb992a07">fromStdMap</a> (const std::map&lt; X, Y &gt; &amp;stdMap)</td></tr>
<tr class="memdesc:a59784d96b6c1bf49512e808aeb992a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion from std::map which might be used inside the library for further processing.  <a href="#a59784d96b6c1bf49512e808aeb992a07">More...</a><br /></td></tr>
<tr class="separator:a59784d96b6c1bf49512e808aeb992a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e59b62ec92191f9c34b5afae851547"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a99e59b62ec92191f9c34b5afae851547"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::map&lt; X, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a99e59b62ec92191f9c34b5afae851547">toStdMap</a> (const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; <a class="el" href="classroyale_1_1_pair.html">Pair</a>&lt; X, Y &gt; &gt; &amp;v)</td></tr>
<tr class="memdesc:a99e59b62ec92191f9c34b5afae851547"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::map which might be used if the element is of type const.  <a href="#a99e59b62ec92191f9c34b5afae851547">More...</a><br /></td></tr>
<tr class="separator:a99e59b62ec92191f9c34b5afae851547"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5edb5cefc81e6bf330c5a6a9c17917e4"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5edb5cefc81e6bf330c5a6a9c17917e4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a5edb5cefc81e6bf330c5a6a9c17917e4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; U &gt; &amp;v)</td></tr>
<tr class="separator:a5edb5cefc81e6bf330c5a6a9c17917e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0262a7aad7c76d8c1c780bb0359c1706"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0262a7aad7c76d8c1c780bb0359c1706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1_vector.html#a0262a7aad7c76d8c1c780bb0359c1706">classswap</a> (<a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; U &gt; &amp;first, <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; U &gt; &amp;second)</td></tr>
<tr class="separator:a0262a7aad7c76d8c1c780bb0359c1706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a5b24e32345710c4c256a7833bf891ee8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1royale__const__iterator.html">royale_const_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae08019bf60c531808d5bc913bdea13ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1royale__const__reverse__iterator.html">royale_const_reverse_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a596916cab061cf6d213d73c5dc1468"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1royale__iterator.html">royale_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html#a8a596916cab061cf6d213d73c5dc1468">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator definitions. </p>

</div>
</div>
<a class="anchor" id="aeef5677686026df4b7feb0c852e3c8c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1royale__reverse__iterator.html">royale_reverse_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html#aeef5677686026df4b7feb0c852e3c8c2">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac80f0477577f681b5b89b3f9609340e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General constructor, which does not allocate memory and sets everything to it's default. </p>
<p>Template implementation. </p>

</div>
</div>
<a class="anchor" id="a2d8e453e6f05088a4110c1b037dddeb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>allocationSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which already performs an allocation of memory during execution. </p>

</div>
</div>
<a class="anchor" id="a62308fb469ae0f131bd84e8a414d4670"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-Constructor for royale compliant vector which allows creation of a royale compliant vector from another royale compliant vector - (NOTE: performs a deep copy!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The royale vector which's memory shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42ac272a9576eb1550b489380294330c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-Constructor for royale compliant vector which allows creation of a royale compliant vector by moving memory (NOTE: performs a shallow copy!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The royale vector which's memory shall be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a779e7fda288a902cf2f3224115fd7624"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-Constructor for STL compliant vector (std::vector) It allows creation of a royale compliant vector from a STL compliant vector - (NOTE: performs a deep copy!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The STL vector to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="classroyale_1_1_vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer list initialization to initialize a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3f6e58246c226d67ad4337f2291e81b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::~<a class="el" href="classroyale_1_1_vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Clears the vectors allocated memory by performing deletion </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a43b07fd1643df83eae61eed42a053016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function automatically checks whether index is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size). </p>
<p>This is in contrast with member operator[], that does not check against bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the vectors storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a9b44a39385f349384309bab89c3a031f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function automatically checks whether index is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size). </p>
<p>This is in contrast with member operator[], that does not check against bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the vectors storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7c16f12392d8d91b61442aec162b24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the vector. </p>
<p>This member function returns a direct reference to the last element in the vector Calling this function on an empty vector will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the last element in the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the vector is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc26ee0d9b58722fa9b80741c9dcdc7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a92bddf7264df486e69edfeda2445dde4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a8a596916cab061cf6d213d73c5dc1468">iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the begin of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ace268dee9b50d0f67f4c75b7f0898408"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afdf5f7e6860d6f6a720e40df40253622"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of allocated slots which are maintained by the vector These allocated slots might be used or unused (refer to <a class="el" href="classroyale_1_1_vector.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) ...">size()</a> for checking the <a class="el" href="classroyale_1_1_vector.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) ...">size()</a> itself) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of allocated slots for the element type which is bound to the vector </dd></dl>

</div>
</div>
<a class="anchor" id="aed1e2d034e48e5ea8ac86c498fc20ce4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an constant iterator to the first position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the begin of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a55d11c4b8def6372d0efea72681f34f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a21f782df7f2729e55faa766dab600132"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an constant iterator to the last position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the end of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a0972ea1fa7ae1d9765375e25f53932fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0654a312b257565b4316e31828d03449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the vector (which are destroyed), leaving the container with a size of 0. </p>
<p>A reallocation is not performed and the vector's capacity is destroyed (everything is freed). </p>

</div>
</div>
<a class="anchor" id="a33bac72044686387ea348da7e5ed5375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the first position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator pointing to the reverse begin of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a803b49472e62da18aff85ff6756dc1d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae1075404e7f466d6a883797a274808c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the last position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator pointing to the reverse end of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a64b35e52427d16dc89b367837f459990"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad18917eb9ec72f0e745c332a8de2c4b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a direct pointer to the memory array used internally by the vector to store its owned elements. </p>
<p>Because elements in the vector are guaranteed to be stored in contiguous storage locations in the same order as represented by the vector, the pointer retrieved can be offset to access any element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>T* A pointer to the first element in the array used internally by the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af8daf6e8b4b66202dddaf7def6702be5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a direct pointer to the memory array used internally by the vector to store its owned elements. </p>
<p>Because elements in the vector are guaranteed to be stored in contiguous storage locations in the same order as represented by the vector, the pointer retrieved can be offset to access any element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>T* A pointer to the first element in the array used internally by the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a348f55e8aa9b70d115a25f9627e4c64a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the vector is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if the vector is empty - otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a56ca430cc9d6c00571e6355aae1a337e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a8a596916cab061cf6d213d73c5dc1468">iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the last position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the end of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ae42c6e55d734794956ed3eca08faaaa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#a5b24e32345710c4c256a7833bf891ee8">const_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a59784d96b6c1bf49512e808aeb992a07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; <a class="el" href="classroyale_1_1_pair.html">Pair</a>&lt;X, Y&gt; &gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::fromStdMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; X, Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>stdMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion from std::map which might be used inside the library for further processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdMap</td><td>The STL compliant map which shall be converted to the API style vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;pair&gt; Returned is a vector of pairs - each pair is holding one entry of the converted std::map </dd></dl>

</div>
</div>
<a class="anchor" id="a153434ad7ad0df07ace7eec3bb31893b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::fromStdVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given std::vector (STL) to the vector type used by the royale API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The STL vector which should be converted to the royale API vector format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The royale API compliant vector format </dd></dl>

</div>
</div>
<a class="anchor" id="a72eb5ad97c226385781f6e43bb1c8dda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the vector. </p>
<p>This member function returns a direct reference to the first element in the vector Calling this function on an empty vector will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the last element in the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the vector is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a708ec6197c4dbffc97d878960deb771e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a41f71c374f40d768bc975e7aada249dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with an STL compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An STL compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a4ebe10418ee8d246952511d3c15c531a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with a royale compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An royale compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a3c4a4d505cf88fbad9cbc75885dcc515"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign another royale compliant vector. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. This method copies all elements held by v into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="ad6a7c5966f867acffb3ee9d942758908"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the contents of an STL compliant vector container by replacing container's current contents if necessary and modifying its size accordingly. </p>
<p>This method copies all elements held by v into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An STL compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a220abd9565189aae49fc449f0fa2ee73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with an STL compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An STL compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a71d4191326fbe77e022e9fad469e6d1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with a royale compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An royale compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a4721e4713d96ef69d4e1dd5e0192f47a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the element at position index in the vector container. </p>
<p>A similar member function, <a class="el" href="classroyale_1_1_vector.html#a43b07fd1643df83eae61eed42a053016" title="The function automatically checks whether index is within the bounds of valid elements in the vector...">at()</a>, has the same behavior as this operator function, except that <a class="el" href="classroyale_1_1_vector.html#a43b07fd1643df83eae61eed42a053016" title="The function automatically checks whether index is within the bounds of valid elements in the vector...">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the vectors storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a68d0189122c4699e72f31b117bfa4d9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the element at position index in the vector container. </p>
<p>A similar member function, <a class="el" href="classroyale_1_1_vector.html#a43b07fd1643df83eae61eed42a053016" title="The function automatically checks whether index is within the bounds of valid elements in the vector...">at()</a>, has the same behavior as this operator function, except that <a class="el" href="classroyale_1_1_vector.html#a43b07fd1643df83eae61eed42a053016" title="The function automatically checks whether index is within the bounds of valid elements in the vector...">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the vectors storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a64296e90d410f55a820ed7b7c4f68bcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last element in the vector, effectively reducing the container size by one. </p>
<p>The last element is destroyed by calling it's destructor; the size is reduced by one BUT there is no reallocation performed to resize the vector to it's contents or to reduce the the vectors capacity by one. The allocated space remains the same. </p>

</div>
</div>
<a class="anchor" id="a403bf1a12bfa57caaca6fb6ac264ac8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the end of the vector, after its current last element. </p>
<p>The content of v is copied to the new element (NOTE: a deep copy is performed!). This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity. </p>

</div>
</div>
<a class="anchor" id="a70dc4131f24750c21979d206f9522f86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31263df515e507529c03067fda24b629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#aeef5677686026df4b7feb0c852e3c8c2">reverse_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the last position (reverse begin) Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the reverse begin of a vector (!= <a class="el" href="classroyale_1_1_vector.html#a56ca430cc9d6c00571e6355aae1a337e" title="Returns an iterator to the last position Calling this function on an empty vector will result in unde...">end()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a88e4eee976007d9511da7b802c9d9e73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a038207d9daef6291aa1b89a21fc1f5b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#aeef5677686026df4b7feb0c852e3c8c2">reverse_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the last position (reverse end) Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the reverse end of a vector (!= <a class="el" href="classroyale_1_1_vector.html#a92bddf7264df486e69edfeda2445dde4" title="Returns an iterator to the first position Calling this function on an empty vector will result in und...">begin()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a42a026a5614b9e50f7389474bbb78a64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1_vector.html#ae08019bf60c531808d5bc913bdea13ac">const_reverse_iterator</a> <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa202553f2fd8c7b4968838d605b15c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the vector to a higher allocation size and allocates the buffers. </p>
<p>Reserves any amount of free allocation slots (allocates the memory already) to be later used for the element-types bound to the given royale vector.</p>
<p>If the given size to reserve is smaller than the already reserved space, then the function return immediately; otherwise the necessary memory allocation is performed and the size is extended to "size"</p><ul>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size (number of element-types) of elements that should be allocated. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a5cc38c00d347551fe1ccd60459561a30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the vector to the given allocation size and initializes the elements (it may shrink) </p>
<p>Creates any amount of elements (allocates the memory already) and moves the existing elements to these slots; afterwards the old space is dumped.</p>
<p>If the given newSize is smaller than the already used slots, the vector will shrink. This means that all elements which are not covered within this capacity (the last ones) will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The amount of slots to remain in the vector (might shrink or enlarge the vector) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa04aba67806bc5797abd769f83852ec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>initVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the vector to the given allocation size and initializes the elements (it may shrink) </p>
<p>Creates any amount of elements (allocates the memory already) and moves the existing elements to these slots; afterwards the old space is dumped.</p>
<p>If the given newSize is smaller than the already used slots, the vector will shrink. This means that all elements which are not covered within this capacity (the last ones) will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The amount of slots to remain in the vector (might shrink or enlarge the vector) </td></tr>
    <tr><td class="paramname">initVal</td><td>The initializer value by which the vector shall be initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af66b9ed5d416b805718ad244ef1f966c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the vector's allocation to it's size Changes the size of the allocated buffer to the vector's size this may result in freeing unneeded memory allocation. </p>

</div>
</div>
<a class="anchor" id="a0ca30cb729aa167dbaef001172b05f7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual size of the vector (this is the used amount of slots in the allocated area) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of the actual used memory slots within the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a2c74beaac3d5b8664b2dbb450dd3e7aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::map&lt;X, Y&gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::toStdMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::map which might be used outside the library by the application for further processing. </p>
<dl class="section return"><dt>Returns</dt><dd>std::map containing the items of the Vector&lt;pairs&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="a99e59b62ec92191f9c34b5afae851547"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::map&lt;X, Y&gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::toStdMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; <a class="el" href="classroyale_1_1_pair.html">Pair</a>&lt; X, Y &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::map which might be used if the element is of type const. </p>
<dl class="section return"><dt>Returns</dt><dd>std::map containing the items of the Vector&lt;pairs&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="a93b04e76ec22e187d5e1faeddd41357c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::toStdVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::vector which might be used outside the library by the application for further processing. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector containing the items of the </dd></dl>

</div>
</div>
<a class="anchor" id="a11d1fdfdf6bb3cfd30b00a1b69912e13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::toStdVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d172e72be02b44ec2d96b8e63d6b4d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classroyale_1_1_vector.html">royale::Vector</a>&lt; T &gt;::toStdVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::vector which might be used if the royale compliant <a class="el" href="classroyale_1_1_vector.html">Vector</a> is a const. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector containing the items of the </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a0262a7aad7c76d8c1c780bb0359c1706"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void classswap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5edb5cefc81e6bf330c5a6a9c17917e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1_vector.html">Vector</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_vector_8hpp_source.html">Vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 23 2015 16:14:29 for Royale by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

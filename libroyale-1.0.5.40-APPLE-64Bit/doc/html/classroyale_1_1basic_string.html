<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Royale: royale::basicString&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="royale-logo-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Royale
   </div>
   <div id="projectbrief">powerful software framework for time-of-flight cameras</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceroyale.html">royale</a></li><li class="navelem"><a class="el" href="classroyale_1_1basic_string.html">basicString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classroyale_1_1basic_string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">royale::basicString&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_string_8hpp_source.html">String.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad3ef779e57c3071ff41933dc563070ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classroyale_1_1royale__iterator.html">royale_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad3ef779e57c3071ff41933dc563070ed">iterator</a></td></tr>
<tr class="memdesc:ad3ef779e57c3071ff41933dc563070ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator definitions.  <a href="#ad3ef779e57c3071ff41933dc563070ed">More...</a><br /></td></tr>
<tr class="separator:ad3ef779e57c3071ff41933dc563070ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d69ead94e19d4241199d25b12625ef4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classroyale_1_1royale__const__iterator.html">royale_const_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a></td></tr>
<tr class="separator:a2d69ead94e19d4241199d25b12625ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33019164e938c2f20c1bde171360bc1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classroyale_1_1royale__reverse__iterator.html">royale_reverse_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab33019164e938c2f20c1bde171360bc1">reverse_iterator</a></td></tr>
<tr class="separator:ab33019164e938c2f20c1bde171360bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc657ee1b591816a44dc8797b5292295"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classroyale_1_1royale__const__reverse__iterator.html">royale_const_reverse_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a></td></tr>
<tr class="separator:abc657ee1b591816a44dc8797b5292295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a849cb5c82de63707e558bab9996f8ef9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a849cb5c82de63707e558bab9996f8ef9">basicString</a> ()</td></tr>
<tr class="memdesc:a849cb5c82de63707e558bab9996f8ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a849cb5c82de63707e558bab9996f8ef9">More...</a><br /></td></tr>
<tr class="separator:a849cb5c82de63707e558bab9996f8ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16c536bb88c352db8a89039d4b1ec64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa16c536bb88c352db8a89039d4b1ec64">basicString</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:aa16c536bb88c352db8a89039d4b1ec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-Constructor for royale compliant string.  <a href="#aa16c536bb88c352db8a89039d4b1ec64">More...</a><br /></td></tr>
<tr class="separator:aa16c536bb88c352db8a89039d4b1ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56594a8cd85bd045aef2d0e3f9d091b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a56594a8cd85bd045aef2d0e3f9d091b8">basicString</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:a56594a8cd85bd045aef2d0e3f9d091b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-Constructor for STL compliant string (std::string)  <a href="#a56594a8cd85bd045aef2d0e3f9d091b8">More...</a><br /></td></tr>
<tr class="separator:a56594a8cd85bd045aef2d0e3f9d091b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07d1648687b09e263059886b174cbdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab07d1648687b09e263059886b174cbdd">basicString</a> (<a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:ab07d1648687b09e263059886b174cbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-Constructor for royale compliant string.  <a href="#ab07d1648687b09e263059886b174cbdd">More...</a><br /></td></tr>
<tr class="separator:ab07d1648687b09e263059886b174cbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d9bed011982b11084913f2c69f7fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a095d9bed011982b11084913f2c69f7fa">basicString</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str, size_t pos, size_t len=npos)</td></tr>
<tr class="memdesc:a095d9bed011982b11084913f2c69f7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows passing a royale compliant string and add it at a given position - the caller might also limit the length that shall be copied (NOTE: performs a deep copy!)  <a href="#a095d9bed011982b11084913f2c69f7fa">More...</a><br /></td></tr>
<tr class="separator:a095d9bed011982b11084913f2c69f7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ebe53d7353e3491ebc116643c467a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a11ebe53d7353e3491ebc116643c467a8">basicString</a> (const std::basic_string&lt; T &gt; &amp;str, size_t pos, size_t len=npos)</td></tr>
<tr class="memdesc:a11ebe53d7353e3491ebc116643c467a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows passing a STL compliant string and add it at a given position - the caller might also limit the length that shall be copied (NOTE: performs a deep copy!)  <a href="#a11ebe53d7353e3491ebc116643c467a8">More...</a><br /></td></tr>
<tr class="separator:a11ebe53d7353e3491ebc116643c467a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060d202e53cf9ae966a13c44df197a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a060d202e53cf9ae966a13c44df197a5c">basicString</a> (const T *s)</td></tr>
<tr class="memdesc:a060d202e53cf9ae966a13c44df197a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows passing a C-Style string to create a royale compliant string (NOTE: performs a deep copy!)  <a href="#a060d202e53cf9ae966a13c44df197a5c">More...</a><br /></td></tr>
<tr class="separator:a060d202e53cf9ae966a13c44df197a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295b071b29fec507d5f6484bff0653cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a295b071b29fec507d5f6484bff0653cd">basicString</a> (const T *s, size_t n)</td></tr>
<tr class="memdesc:a295b071b29fec507d5f6484bff0653cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows passing a C-Style string to create a royale compliant string by copying the first n bytes (NOTE: performs a deep copy!)  <a href="#a295b071b29fec507d5f6484bff0653cd">More...</a><br /></td></tr>
<tr class="separator:a295b071b29fec507d5f6484bff0653cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c39fec67ca9c71be71ac3b7c79cc8e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a2c39fec67ca9c71be71ac3b7c79cc8e3">basicString</a> (size_t n, T c)</td></tr>
<tr class="memdesc:a2c39fec67ca9c71be71ac3b7c79cc8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows creating a royale compliant string with n slots which are initialized by character c.  <a href="#a2c39fec67ca9c71be71ac3b7c79cc8e3">More...</a><br /></td></tr>
<tr class="separator:a2c39fec67ca9c71be71ac3b7c79cc8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0783454d063ac865be29c630a23bbe57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0783454d063ac865be29c630a23bbe57">basicString</a> (const std::initializer_list&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:a0783454d063ac865be29c630a23bbe57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list initialization to initialize a string.  <a href="#a0783454d063ac865be29c630a23bbe57">More...</a><br /></td></tr>
<tr class="separator:a0783454d063ac865be29c630a23bbe57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334aade8c84f9ea903687ab4a0a6ec9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a334aade8c84f9ea903687ab4a0a6ec9e">~basicString</a> ()</td></tr>
<tr class="memdesc:a334aade8c84f9ea903687ab4a0a6ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a334aade8c84f9ea903687ab4a0a6ec9e">More...</a><br /></td></tr>
<tr class="separator:a334aade8c84f9ea903687ab4a0a6ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48df31da4d8c5f4b82cb62113834dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3">size</a> () const </td></tr>
<tr class="memdesc:ad48df31da4d8c5f4b82cb62113834dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size/length of the string (this is the used amount of slots in the allocated area)  <a href="#ad48df31da4d8c5f4b82cb62113834dc3">More...</a><br /></td></tr>
<tr class="separator:ad48df31da4d8c5f4b82cb62113834dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af809776b19cba7a749809095208e0aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af809776b19cba7a749809095208e0aeb">length</a> () const </td></tr>
<tr class="memdesc:af809776b19cba7a749809095208e0aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size/length of the string (this is the used amount of slots in the allocated area)  <a href="#af809776b19cba7a749809095208e0aeb">More...</a><br /></td></tr>
<tr class="separator:af809776b19cba7a749809095208e0aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c32ccae743c4e5be4503a73e668921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a61c32ccae743c4e5be4503a73e668921">empty</a> () const </td></tr>
<tr class="memdesc:a61c32ccae743c4e5be4503a73e668921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the string is empty.  <a href="#a61c32ccae743c4e5be4503a73e668921">More...</a><br /></td></tr>
<tr class="separator:a61c32ccae743c4e5be4503a73e668921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a7db4b08f705cfc1a6a7a28d41f76e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab0a7db4b08f705cfc1a6a7a28d41f76e">capacity</a> () const </td></tr>
<tr class="memdesc:ab0a7db4b08f705cfc1a6a7a28d41f76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of allocated slots which are maintained by the vector These allocated slots might be used or unused (refer to <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3" title="Returns the actual size/length of the string (this is the used amount of slots in the allocated area)...">size()</a> for checking the <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3" title="Returns the actual size/length of the string (this is the used amount of slots in the allocated area)...">size()</a> itself)  <a href="#ab0a7db4b08f705cfc1a6a7a28d41f76e">More...</a><br /></td></tr>
<tr class="separator:ab0a7db4b08f705cfc1a6a7a28d41f76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef0a972c25f517b42bff5d4f22867bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#afef0a972c25f517b42bff5d4f22867bc">data</a> ()</td></tr>
<tr class="memdesc:afef0a972c25f517b42bff5d4f22867bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direct pointer to the memory array used internally by the string to store its owned elements.  <a href="#afef0a972c25f517b42bff5d4f22867bc">More...</a><br /></td></tr>
<tr class="separator:afef0a972c25f517b42bff5d4f22867bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9354acd2c34f8a317da08a3d51f3627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ae9354acd2c34f8a317da08a3d51f3627">data</a> () const </td></tr>
<tr class="memdesc:ae9354acd2c34f8a317da08a3d51f3627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direct pointer to the memory array used internally by the string to store its owned elements.  <a href="#ae9354acd2c34f8a317da08a3d51f3627">More...</a><br /></td></tr>
<tr class="separator:ae9354acd2c34f8a317da08a3d51f3627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb106ac4582f9b2714401e6d5faf070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8cb106ac4582f9b2714401e6d5faf070">front</a> ()</td></tr>
<tr class="memdesc:a8cb106ac4582f9b2714401e6d5faf070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the string.  <a href="#a8cb106ac4582f9b2714401e6d5faf070">More...</a><br /></td></tr>
<tr class="separator:a8cb106ac4582f9b2714401e6d5faf070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b29e24293dbe4132c8ce6f188536d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0b29e24293dbe4132c8ce6f188536d51">front</a> () const </td></tr>
<tr class="separator:a0b29e24293dbe4132c8ce6f188536d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b0cf8bff03b47c187c33b817bb0680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#ad3ef779e57c3071ff41933dc563070ed">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a36b0cf8bff03b47c187c33b817bb0680">begin</a> ()</td></tr>
<tr class="memdesc:a36b0cf8bff03b47c187c33b817bb0680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first position Calling this function on an empty string will result in undefined behavior.  <a href="#a36b0cf8bff03b47c187c33b817bb0680">More...</a><br /></td></tr>
<tr class="separator:a36b0cf8bff03b47c187c33b817bb0680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa1200fee4d522b0b45360149f6715d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6fa1200fee4d522b0b45360149f6715d">begin</a> () const </td></tr>
<tr class="separator:a6fa1200fee4d522b0b45360149f6715d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c73e750806fc3e9c3b5b7861efba7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#ad3ef779e57c3071ff41933dc563070ed">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a57c73e750806fc3e9c3b5b7861efba7f">end</a> ()</td></tr>
<tr class="memdesc:a57c73e750806fc3e9c3b5b7861efba7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the last position Calling this function on an empty string will result in undefined behavior.  <a href="#a57c73e750806fc3e9c3b5b7861efba7f">More...</a><br /></td></tr>
<tr class="separator:a57c73e750806fc3e9c3b5b7861efba7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d7cfe2ddf92185b67ae87b61cd4aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad6d7cfe2ddf92185b67ae87b61cd4aa0">end</a> () const </td></tr>
<tr class="separator:ad6d7cfe2ddf92185b67ae87b61cd4aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76112d5334433ad4b9aa747382f78392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#ab33019164e938c2f20c1bde171360bc1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a76112d5334433ad4b9aa747382f78392">rbegin</a> ()</td></tr>
<tr class="memdesc:a76112d5334433ad4b9aa747382f78392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse begin (last position) Calling this function on an empty string will result in undefined behavior.  <a href="#a76112d5334433ad4b9aa747382f78392">More...</a><br /></td></tr>
<tr class="separator:a76112d5334433ad4b9aa747382f78392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e072592e1617bc3f0274ffd0f66dd9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a2e072592e1617bc3f0274ffd0f66dd9c">rbegin</a> () const </td></tr>
<tr class="separator:a2e072592e1617bc3f0274ffd0f66dd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528e6466411c2143e01941af870ee1be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#ab33019164e938c2f20c1bde171360bc1">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a528e6466411c2143e01941af870ee1be">rend</a> ()</td></tr>
<tr class="memdesc:a528e6466411c2143e01941af870ee1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse end (first position) Calling this function on an empty string will result in undefined behavior.  <a href="#a528e6466411c2143e01941af870ee1be">More...</a><br /></td></tr>
<tr class="separator:a528e6466411c2143e01941af870ee1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7788c014d94a0357bd52b5f4e3282862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7788c014d94a0357bd52b5f4e3282862">rend</a> () const </td></tr>
<tr class="separator:a7788c014d94a0357bd52b5f4e3282862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5a29b7c5f74bf1723fa97ea2de7df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#afc5a29b7c5f74bf1723fa97ea2de7df7">cbegin</a> ()</td></tr>
<tr class="memdesc:afc5a29b7c5f74bf1723fa97ea2de7df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the begin of the string (first position) Calling this function on an empty string will result in undefined behavior.  <a href="#afc5a29b7c5f74bf1723fa97ea2de7df7">More...</a><br /></td></tr>
<tr class="separator:afc5a29b7c5f74bf1723fa97ea2de7df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cfa44a6bc4a10d434203816c0cf724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a24cfa44a6bc4a10d434203816c0cf724">cbegin</a> () const </td></tr>
<tr class="separator:a24cfa44a6bc4a10d434203816c0cf724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d4401ebbd680902714012871f0111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#acd7d4401ebbd680902714012871f0111">cend</a> ()</td></tr>
<tr class="memdesc:acd7d4401ebbd680902714012871f0111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end of the string (last position) Calling this function on an empty string will result in undefined behavior.  <a href="#acd7d4401ebbd680902714012871f0111">More...</a><br /></td></tr>
<tr class="separator:acd7d4401ebbd680902714012871f0111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f641a0d250e18d0e3e85002a2cc6b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0f641a0d250e18d0e3e85002a2cc6b1f">cend</a> () const </td></tr>
<tr class="separator:a0f641a0d250e18d0e3e85002a2cc6b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7454817195eb8cb6f2dd411b7efd709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab7454817195eb8cb6f2dd411b7efd709">crbegin</a> ()</td></tr>
<tr class="memdesc:ab7454817195eb8cb6f2dd411b7efd709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the reverse begin of the string (last position) Calling this function on an empty string will result in undefined behavior.  <a href="#ab7454817195eb8cb6f2dd411b7efd709">More...</a><br /></td></tr>
<tr class="separator:ab7454817195eb8cb6f2dd411b7efd709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcac67ef73afbf048fc177cf703a848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#abbcac67ef73afbf048fc177cf703a848">crbegin</a> () const </td></tr>
<tr class="separator:abbcac67ef73afbf048fc177cf703a848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c7d58bf4cbeafaea2a81eefabe0c4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a98c7d58bf4cbeafaea2a81eefabe0c4d">crend</a> ()</td></tr>
<tr class="memdesc:a98c7d58bf4cbeafaea2a81eefabe0c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the reverse end of the string (first position) Calling this function on an empty string will result in undefined behavior.  <a href="#a98c7d58bf4cbeafaea2a81eefabe0c4d">More...</a><br /></td></tr>
<tr class="separator:a98c7d58bf4cbeafaea2a81eefabe0c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e2e9c374b0c64c18a972ea4b2cd35b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a99e2e9c374b0c64c18a972ea4b2cd35b">crend</a> () const </td></tr>
<tr class="separator:a99e2e9c374b0c64c18a972ea4b2cd35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d27ea55b0638d7d3cf451a8eeba4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a64d27ea55b0638d7d3cf451a8eeba4c7">back</a> ()</td></tr>
<tr class="memdesc:a64d27ea55b0638d7d3cf451a8eeba4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the string.  <a href="#a64d27ea55b0638d7d3cf451a8eeba4c7">More...</a><br /></td></tr>
<tr class="separator:a64d27ea55b0638d7d3cf451a8eeba4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6e825f914dce79aacefded90b3bfa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a3f6e825f914dce79aacefded90b3bfa3">back</a> () const </td></tr>
<tr class="separator:a3f6e825f914dce79aacefded90b3bfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff17794f88e1107b3a2e89e2bf0afde6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aff17794f88e1107b3a2e89e2bf0afde6">push_back</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:aff17794f88e1107b3a2e89e2bf0afde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the string, after its current last element.  <a href="#aff17794f88e1107b3a2e89e2bf0afde6">More...</a><br /></td></tr>
<tr class="separator:aff17794f88e1107b3a2e89e2bf0afde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7033616dddc037749c3cb6a8935fc88d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7033616dddc037749c3cb6a8935fc88d">push_back</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="separator:a7033616dddc037749c3cb6a8935fc88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3009df262d03ec25bb308501c65f824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ab3009df262d03ec25bb308501c65f824">push_back</a> (const std::basic_string&lt; T &gt; &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:ab3009df262d03ec25bb308501c65f824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ed47847028e76ad19810cbe8dcfe2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a50ed47847028e76ad19810cbe8dcfe2d">push_back</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:a50ed47847028e76ad19810cbe8dcfe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc2dca452a65908b63266f21f4b29de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#addc2dca452a65908b63266f21f4b29de">push_back</a> (const T *str)</td></tr>
<tr class="separator:addc2dca452a65908b63266f21f4b29de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18d78393183efce70780049078379a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9c18d78393183efce70780049078379a">push_back</a> (const T *str, size_t n)</td></tr>
<tr class="separator:a9c18d78393183efce70780049078379a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ed99a88bf1c232068b4dc8ae6d413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6b5ed99a88bf1c232068b4dc8ae6d413">push_back</a> (size_t n, T c)</td></tr>
<tr class="separator:a6b5ed99a88bf1c232068b4dc8ae6d413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3a81a50aa0d0f3055caf3bc2d6de93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ace3a81a50aa0d0f3055caf3bc2d6de93">push_back</a> (const T c)</td></tr>
<tr class="separator:ace3a81a50aa0d0f3055caf3bc2d6de93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08c6fb824a972346fff20ea92794331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af08c6fb824a972346fff20ea92794331">append</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:af08c6fb824a972346fff20ea92794331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the string, after its current last element and returns the actual string element.  <a href="#af08c6fb824a972346fff20ea92794331">More...</a><br /></td></tr>
<tr class="separator:af08c6fb824a972346fff20ea92794331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8232e4e559b251e4d304b9e520d7643e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8232e4e559b251e4d304b9e520d7643e">append</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="separator:a8232e4e559b251e4d304b9e520d7643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc7fbaabcaa7911379e33a23f044ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#adcc7fbaabcaa7911379e33a23f044ea7">append</a> (const std::basic_string&lt; T &gt; &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:adcc7fbaabcaa7911379e33a23f044ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f4ac053c4b73faf7c71fde481e4387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a71f4ac053c4b73faf7c71fde481e4387">append</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str, size_t subpos, size_t sublen)</td></tr>
<tr class="separator:a71f4ac053c4b73faf7c71fde481e4387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cc3ed778fbb661776391595993e119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a38cc3ed778fbb661776391595993e119">append</a> (const T *str)</td></tr>
<tr class="separator:a38cc3ed778fbb661776391595993e119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024faa49d8010fbcb0372d25a284c91f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a024faa49d8010fbcb0372d25a284c91f">append</a> (const T *str, size_t n)</td></tr>
<tr class="separator:a024faa49d8010fbcb0372d25a284c91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad153702cf2e8d04d728dbd62ab659940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ad153702cf2e8d04d728dbd62ab659940">append</a> (size_t n, T c)</td></tr>
<tr class="separator:ad153702cf2e8d04d728dbd62ab659940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae2cfa6e7f521e2a63a0aedd3b46375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aeae2cfa6e7f521e2a63a0aedd3b46375">append</a> (const T c)</td></tr>
<tr class="separator:aeae2cfa6e7f521e2a63a0aedd3b46375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5adfabbcfaa4dc8f33ece4bb424287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a5f5adfabbcfaa4dc8f33ece4bb424287">operator+=</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:a5f5adfabbcfaa4dc8f33ece4bb424287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the string, after its current last element and returns the actual string element.  <a href="#a5f5adfabbcfaa4dc8f33ece4bb424287">More...</a><br /></td></tr>
<tr class="separator:a5f5adfabbcfaa4dc8f33ece4bb424287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6d96f0b1ad3a1c28ab61ce6f52919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a51c6d96f0b1ad3a1c28ab61ce6f52919">operator+=</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="separator:a51c6d96f0b1ad3a1c28ab61ce6f52919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76856ac5023d9a1d437607a74034ff00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a76856ac5023d9a1d437607a74034ff00">operator+=</a> (const T *s)</td></tr>
<tr class="separator:a76856ac5023d9a1d437607a74034ff00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff8a7c5d2a0cfc6434221b818c5fd01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9ff8a7c5d2a0cfc6434221b818c5fd01">operator+=</a> (const T s)</td></tr>
<tr class="separator:a9ff8a7c5d2a0cfc6434221b818c5fd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db1a86f363b6c6b9267352a9638e192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6db1a86f363b6c6b9267352a9638e192">operator+</a> (const std::basic_string&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a6db1a86f363b6c6b9267352a9638e192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two stirngs and returns the result (the second string is appended) The content of str is copied to the newly created element (NOTE: a deep copy is performed!).  <a href="#a6db1a86f363b6c6b9267352a9638e192">More...</a><br /></td></tr>
<tr class="separator:a6db1a86f363b6c6b9267352a9638e192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8526b68e24a8c7bc514288ef20030441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a8526b68e24a8c7bc514288ef20030441">operator+</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="separator:a8526b68e24a8c7bc514288ef20030441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0bc4697cf123ff2c93ab3ae368e31c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6b0bc4697cf123ff2c93ab3ae368e31c">operator+</a> (const T *s) const </td></tr>
<tr class="separator:a6b0bc4697cf123ff2c93ab3ae368e31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40315b22baee696456acf7baa75643a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a40315b22baee696456acf7baa75643a7">operator+</a> (const T s) const </td></tr>
<tr class="separator:a40315b22baee696456acf7baa75643a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93b4a2fe21f91028344afeb6a0ac568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa93b4a2fe21f91028344afeb6a0ac568">pop_back</a> ()</td></tr>
<tr class="memdesc:aa93b4a2fe21f91028344afeb6a0ac568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element in the string, effectively reducing the container size by one.  <a href="#aa93b4a2fe21f91028344afeb6a0ac568">More...</a><br /></td></tr>
<tr class="separator:aa93b4a2fe21f91028344afeb6a0ac568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7695f287c0aee6474e3366f7f6f389f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7695f287c0aee6474e3366f7f6f389f7">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:a7695f287c0aee6474e3366f7f6f389f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element.  <a href="#a7695f287c0aee6474e3366f7f6f389f7">More...</a><br /></td></tr>
<tr class="separator:a7695f287c0aee6474e3366f7f6f389f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed81540a238ab1c8a56530f25b71f2c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aed81540a238ab1c8a56530f25b71f2c1">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:aed81540a238ab1c8a56530f25b71f2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element.  <a href="#aed81540a238ab1c8a56530f25b71f2c1">More...</a><br /></td></tr>
<tr class="separator:aed81540a238ab1c8a56530f25b71f2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c509c3292d15c832190dd2e56157680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680">at</a> (size_t index)</td></tr>
<tr class="memdesc:a5c509c3292d15c832190dd2e56157680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element.  <a href="#a5c509c3292d15c832190dd2e56157680">More...</a><br /></td></tr>
<tr class="separator:a5c509c3292d15c832190dd2e56157680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2927b2043c70b3ea78ac9141866c2a55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a2927b2043c70b3ea78ac9141866c2a55">at</a> (size_t index) const </td></tr>
<tr class="memdesc:a2927b2043c70b3ea78ac9141866c2a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element.  <a href="#a2927b2043c70b3ea78ac9141866c2a55">More...</a><br /></td></tr>
<tr class="separator:a2927b2043c70b3ea78ac9141866c2a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc01fd5b4ae4c87d37b71ba0976d90da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#afc01fd5b4ae4c87d37b71ba0976d90da">operator=</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:afc01fd5b4ae4c87d37b71ba0976d90da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign another royale compliant string.  <a href="#afc01fd5b4ae4c87d37b71ba0976d90da">More...</a><br /></td></tr>
<tr class="separator:afc01fd5b4ae4c87d37b71ba0976d90da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b3431347eae688334fd7855d49382f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a83b3431347eae688334fd7855d49382f">operator=</a> (<a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;str)</td></tr>
<tr class="memdesc:a83b3431347eae688334fd7855d49382f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move elements to another royale compliant string.  <a href="#a83b3431347eae688334fd7855d49382f">More...</a><br /></td></tr>
<tr class="separator:a83b3431347eae688334fd7855d49382f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5faa84d758be2c15f49c3e6997dec6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ac5faa84d758be2c15f49c3e6997dec6a">operator=</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:ac5faa84d758be2c15f49c3e6997dec6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the contents of an STL compliant string container by replacing container's current contents if necessary and modifying its size accordingly.  <a href="#ac5faa84d758be2c15f49c3e6997dec6a">More...</a><br /></td></tr>
<tr class="separator:ac5faa84d758be2c15f49c3e6997dec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06c964b23013a298137907e97bcf1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9f06c964b23013a298137907e97bcf1d">operator=</a> (const T *str)</td></tr>
<tr class="memdesc:a9f06c964b23013a298137907e97bcf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the contents of an C-Style compliant string container by replacing container's current contents if necessary and modifying its size accordingly.  <a href="#a9f06c964b23013a298137907e97bcf1d">More...</a><br /></td></tr>
<tr class="separator:a9f06c964b23013a298137907e97bcf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b9d69ca31d55f25190faf2154f7677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a80b9d69ca31d55f25190faf2154f7677">operator=</a> (const T str)</td></tr>
<tr class="memdesc:a80b9d69ca31d55f25190faf2154f7677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a character to a royale compliant string container by replacing container's current contents and modifying its size accordingly.  <a href="#a80b9d69ca31d55f25190faf2154f7677">More...</a><br /></td></tr>
<tr class="separator:a80b9d69ca31d55f25190faf2154f7677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc5379d5781fdcac8bcc499e4fe7773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7cc5379d5781fdcac8bcc499e4fe7773">operator==</a> (const std::basic_string&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a7cc5379d5781fdcac8bcc499e4fe7773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with an STL compliant vector.  <a href="#a7cc5379d5781fdcac8bcc499e4fe7773">More...</a><br /></td></tr>
<tr class="separator:a7cc5379d5781fdcac8bcc499e4fe7773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceff1b415565de95e42174eb9ca1f79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a7ceff1b415565de95e42174eb9ca1f79">operator==</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a7ceff1b415565de95e42174eb9ca1f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with a royale compliant string.  <a href="#a7ceff1b415565de95e42174eb9ca1f79">More...</a><br /></td></tr>
<tr class="separator:a7ceff1b415565de95e42174eb9ca1f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058d0e17bca7e293ebb7a9ece4d66b1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a058d0e17bca7e293ebb7a9ece4d66b1d">operator==</a> (const T *str) const </td></tr>
<tr class="memdesc:a058d0e17bca7e293ebb7a9ece4d66b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with a C-Style string.  <a href="#a058d0e17bca7e293ebb7a9ece4d66b1d">More...</a><br /></td></tr>
<tr class="separator:a058d0e17bca7e293ebb7a9ece4d66b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c155f20985f6a8c371c81862c559b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a4c155f20985f6a8c371c81862c559b0c">operator!=</a> (const std::basic_string&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a4c155f20985f6a8c371c81862c559b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with an STL compliant string.  <a href="#a4c155f20985f6a8c371c81862c559b0c">More...</a><br /></td></tr>
<tr class="separator:a4c155f20985f6a8c371c81862c559b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f12322ce9719d9f8f6cd5d148bbc1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a1f12322ce9719d9f8f6cd5d148bbc1e7">operator!=</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str) const </td></tr>
<tr class="memdesc:a1f12322ce9719d9f8f6cd5d148bbc1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with a royale compliant string.  <a href="#a1f12322ce9719d9f8f6cd5d148bbc1e7">More...</a><br /></td></tr>
<tr class="separator:a1f12322ce9719d9f8f6cd5d148bbc1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b558cbb9058a238d0985e38c8b6365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a20b558cbb9058a238d0985e38c8b6365">operator!=</a> (const T *str) const </td></tr>
<tr class="memdesc:a20b558cbb9058a238d0985e38c8b6365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with a C-Style string.  <a href="#a20b558cbb9058a238d0985e38c8b6365">More...</a><br /></td></tr>
<tr class="separator:a20b558cbb9058a238d0985e38c8b6365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326406f8b4f3c430150441c8f1152377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a326406f8b4f3c430150441c8f1152377">clear</a> ()</td></tr>
<tr class="memdesc:a326406f8b4f3c430150441c8f1152377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the string (which are destroyed), leaving the container with a size of 0.  <a href="#a326406f8b4f3c430150441c8f1152377">More...</a><br /></td></tr>
<tr class="separator:a326406f8b4f3c430150441c8f1152377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de316077ddd24a4cad3df61d155438b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9de316077ddd24a4cad3df61d155438b">resize</a> (size_t newSize)</td></tr>
<tr class="memdesc:a9de316077ddd24a4cad3df61d155438b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the string to the given allocation size and allocates the buffers (it may shrink)  <a href="#a9de316077ddd24a4cad3df61d155438b">More...</a><br /></td></tr>
<tr class="separator:a9de316077ddd24a4cad3df61d155438b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c953106f528c47f9f3e80d201a7f79d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a0c953106f528c47f9f3e80d201a7f79d">reserve</a> (size_t <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3">size</a>)</td></tr>
<tr class="memdesc:a0c953106f528c47f9f3e80d201a7f79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the string to a higher allocation size and allocates the buffers.  <a href="#a0c953106f528c47f9f3e80d201a7f79d">More...</a><br /></td></tr>
<tr class="separator:a0c953106f528c47f9f3e80d201a7f79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552e9b0cbbf0be9a2594ee2a7afc7fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6552e9b0cbbf0be9a2594ee2a7afc7fc">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a6552e9b0cbbf0be9a2594ee2a7afc7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the string's allocation to it's size.  <a href="#a6552e9b0cbbf0be9a2594ee2a7afc7fc">More...</a><br /></td></tr>
<tr class="separator:a6552e9b0cbbf0be9a2594ee2a7afc7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4373ddb9e02283f68e3c86e67cb47d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a4373ddb9e02283f68e3c86e67cb47d06">c_str</a> ()</td></tr>
<tr class="memdesc:a4373ddb9e02283f68e3c86e67cb47d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the royale string object to a C-Style array.  <a href="#a4373ddb9e02283f68e3c86e67cb47d06">More...</a><br /></td></tr>
<tr class="separator:a4373ddb9e02283f68e3c86e67cb47d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873798ac4037d14b84a30112548bf8fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a873798ac4037d14b84a30112548bf8fa">c_str</a> () const </td></tr>
<tr class="separator:a873798ac4037d14b84a30112548bf8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4026263abecc74c22fe58b57a00673a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::basic_string&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a4026263abecc74c22fe58b57a00673a8">toStdString</a> ()</td></tr>
<tr class="memdesc:a4026263abecc74c22fe58b57a00673a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::basic_string which might be used outside the library by the application for further processing.  <a href="#a4026263abecc74c22fe58b57a00673a8">More...</a><br /></td></tr>
<tr class="separator:a4026263abecc74c22fe58b57a00673a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eb98ed08a7881fc13df7bc3cb0590b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a83eb98ed08a7881fc13df7bc3cb0590b">max_size</a> () const </td></tr>
<tr class="memdesc:a83eb98ed08a7881fc13df7bc3cb0590b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max_size of the string.  <a href="#a83eb98ed08a7881fc13df7bc3cb0590b">More...</a><br /></td></tr>
<tr class="separator:a83eb98ed08a7881fc13df7bc3cb0590b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af078b6af10bf0b399622770dd0392cbb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af078b6af10bf0b399622770dd0392cbb">fromStdString</a> (const std::basic_string&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:af078b6af10bf0b399622770dd0392cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given std::basic_string (STL) to the string type used by the royale API.  <a href="#af078b6af10bf0b399622770dd0392cbb">More...</a><br /></td></tr>
<tr class="separator:af078b6af10bf0b399622770dd0392cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20a3a242190219153949708d4f5bf2c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#af20a3a242190219153949708d4f5bf2c">fromCArray</a> (const T *str)</td></tr>
<tr class="memdesc:af20a3a242190219153949708d4f5bf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C-Style array to the string type used by the royale API.  <a href="#af20a3a242190219153949708d4f5bf2c">More...</a><br /></td></tr>
<tr class="separator:af20a3a242190219153949708d4f5bf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae802348bb773c01dc233ee599a3853f8"><td class="memTemplParams" colspan="2">template&lt;typename... Dummy, typename U , typename Type  = T&gt; </td></tr>
<tr class="memitem:ae802348bb773c01dc233ee599a3853f8"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::enable_if&lt; std::is_same&lt; Type, char &gt;::value, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; Type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#ae802348bb773c01dc233ee599a3853f8">fromAny</a> (const U value)</td></tr>
<tr class="memdesc:ae802348bb773c01dc233ee599a3853f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to String from any Type.  <a href="#ae802348bb773c01dc233ee599a3853f8">More...</a><br /></td></tr>
<tr class="separator:ae802348bb773c01dc233ee599a3853f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e75298044d395dc5166b8c34c3f822"><td class="memTemplParams" colspan="2">template&lt;typename... Dummy, typename U , typename Type  = T&gt; </td></tr>
<tr class="memitem:aa1e75298044d395dc5166b8c34c3f822"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::enable_if&lt; std::is_same&lt; Type, wchar_t &gt;::value, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; Type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aa1e75298044d395dc5166b8c34c3f822">fromAny</a> (const U value)</td></tr>
<tr class="memdesc:aa1e75298044d395dc5166b8c34c3f822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to WString from any Type.  <a href="#aa1e75298044d395dc5166b8c34c3f822">More...</a><br /></td></tr>
<tr class="separator:aa1e75298044d395dc5166b8c34c3f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e28ae9f19d0fcca35fdb3cc21424098"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a9e28ae9f19d0fcca35fdb3cc21424098">fromInt</a> (int value)</td></tr>
<tr class="memdesc:a9e28ae9f19d0fcca35fdb3cc21424098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to String from Int.  <a href="#a9e28ae9f19d0fcca35fdb3cc21424098">More...</a><br /></td></tr>
<tr class="separator:a9e28ae9f19d0fcca35fdb3cc21424098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd220dd6d384a1dd770ab7f175b2085"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a6cd220dd6d384a1dd770ab7f175b2085">fromUInt</a> (unsigned int value)</td></tr>
<tr class="memdesc:a6cd220dd6d384a1dd770ab7f175b2085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to String from unsigned Int.  <a href="#a6cd220dd6d384a1dd770ab7f175b2085">More...</a><br /></td></tr>
<tr class="separator:a6cd220dd6d384a1dd770ab7f175b2085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9e942a9588aa0e7e734e106ce30383"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::basic_string&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#aea9e942a9588aa0e7e734e106ce30383">toStdString</a> (const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;str)</td></tr>
<tr class="memdesc:aea9e942a9588aa0e7e734e106ce30383"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::basic_string which might be used if the royale compliant string is a const.  <a href="#aea9e942a9588aa0e7e734e106ce30383">More...</a><br /></td></tr>
<tr class="separator:aea9e942a9588aa0e7e734e106ce30383"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a454da36bff6bdbad033ccb9da2cc400e"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a454da36bff6bdbad033ccb9da2cc400e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classroyale_1_1basic_string.html#a454da36bff6bdbad033ccb9da2cc400e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; U &gt; &amp;str)</td></tr>
<tr class="separator:a454da36bff6bdbad033ccb9da2cc400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a2d69ead94e19d4241199d25b12625ef4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1royale__const__iterator.html">royale_const_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc657ee1b591816a44dc8797b5292295"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1royale__const__reverse__iterator.html">royale_const_reverse_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3ef779e57c3071ff41933dc563070ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1royale__iterator.html">royale_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ad3ef779e57c3071ff41933dc563070ed">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator definitions. </p>

</div>
</div>
<a class="anchor" id="ab33019164e938c2f20c1bde171360bc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classroyale_1_1royale__reverse__iterator.html">royale_reverse_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html#ab33019164e938c2f20c1bde171360bc1">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a849cb5c82de63707e558bab9996f8ef9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Template implementation.</p>
<p>General constructor, which does not allocate memory and sets everything to it's default </p>

</div>
</div>
<a class="anchor" id="aa16c536bb88c352db8a89039d4b1ec64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-Constructor for royale compliant string. </p>
<p>Copy constructor which allows creation of a royale compliant string from another royale compliant string - (NOTE: performs a deep copy!)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The royale vector which's memory shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56594a8cd85bd045aef2d0e3f9d091b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-Constructor for STL compliant string (std::string) </p>
<p>Copy constructor which allows creation of a royale compliant string from a STL compliant string - (NOTE: performs a deep copy!)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The STL string to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab07d1648687b09e263059886b174cbdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-Constructor for royale compliant string. </p>
<p>Constructor which allows creation of a royale compliant string by moving memory (NOTE: performs a shallow copy!)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The royale string which's memory shall be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a095d9bed011982b11084913f2c69f7fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows passing a royale compliant string and add it at a given position - the caller might also limit the length that shall be copied (NOTE: performs a deep copy!) </p>
<p>If the len would exceed the length of str then all bytes till the end of str are copied to the new string object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The royale string which shall be copied </td></tr>
    <tr><td class="paramname">pos</td><td>The position where to start to copy bytes </td></tr>
    <tr><td class="paramname">len</td><td>The length/amount of bytes that shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11ebe53d7353e3491ebc116643c467a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows passing a STL compliant string and add it at a given position - the caller might also limit the length that shall be copied (NOTE: performs a deep copy!) </p>
<p>If the len would exceed the length of str then all bytes till the end of str are copied to the new string object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The STL compliant string which shall be copied </td></tr>
    <tr><td class="paramname">pos</td><td>The position where to start to copy bytes </td></tr>
    <tr><td class="paramname">len</td><td>The length/amount of bytes that shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a060d202e53cf9ae966a13c44df197a5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows passing a C-Style string to create a royale compliant string (NOTE: performs a deep copy!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The C-Style compliant string which shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a295b071b29fec507d5f6484bff0653cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows passing a C-Style string to create a royale compliant string by copying the first n bytes (NOTE: performs a deep copy!) </p>
<p>If n is bigger than the length of s, then n is allocated and the length of s is used for copying - this results in a string with unused allocated space and the value of where s points to.</p>
<p>If n is smaller than the length of s, then n is allocated and only n bytes from s are copied to the string object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The C-Style compliant string which shall be copied </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c39fec67ca9c71be71ac3b7c79cc8e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor which allows creating a royale compliant string with n slots which are initialized by character c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of slots that shall be reserved </td></tr>
    <tr><td class="paramname">c</td><td>The character which is used for the slot's initialization </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0783454d063ac865be29c630a23bbe57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer list initialization to initialize a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a334aade8c84f9ea903687ab4a0a6ec9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::~<a class="el" href="classroyale_1_1basic_string.html">basicString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Clears the string's allocated memory by performing deletion </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af08c6fb824a972346fff20ea92794331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the end of the string, after its current last element and returns the actual string element. </p>
<p>The content of str is copied to the new element (NOTE: a deep copy is performed!). This effectively increases the container size, which causes an automatic reallocation of the allocated storage space if -and only if- the new string size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a8232e4e559b251e4d304b9e520d7643e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adcc7fbaabcaa7911379e33a23f044ea7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a71f4ac053c4b73faf7c71fde481e4387"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38cc3ed778fbb661776391595993e119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a024faa49d8010fbcb0372d25a284c91f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad153702cf2e8d04d728dbd62ab659940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeae2cfa6e7f521e2a63a0aedd3b46375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c509c3292d15c832190dd2e56157680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element. </p>
<p>The function automatically checks whether index is within the bounds of valid elements in the string, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size). This is in contrast with member operator[], that does not check against bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the string's storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the string </dd></dl>

</div>
</div>
<a class="anchor" id="a2927b2043c70b3ea78ac9141866c2a55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element. </p>
<p>The function automatically checks whether index is within the bounds of valid elements in the string, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size). This is in contrast with member operator[], that does not check against bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the string's storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the string </dd></dl>

</div>
</div>
<a class="anchor" id="a64d27ea55b0638d7d3cf451a8eeba4c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the string. </p>
<p>Calling this function on an empty vector will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the last element in the string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the string is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f6e825f914dce79aacefded90b3bfa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a36b0cf8bff03b47c187c33b817bb0680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#ad3ef779e57c3071ff41933dc563070ed">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first position Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator to the begin of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fa1200fee4d522b0b45360149f6715d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4373ddb9e02283f68e3c86e67cb47d06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the royale string object to a C-Style array. </p>
<dl class="section return"><dt>Returns</dt><dd>T* The C-Style Array </dd></dl>

</div>
</div>
<a class="anchor" id="a873798ac4037d14b84a30112548bf8fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0a7db4b08f705cfc1a6a7a28d41f76e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of allocated slots which are maintained by the vector These allocated slots might be used or unused (refer to <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3" title="Returns the actual size/length of the string (this is the used amount of slots in the allocated area)...">size()</a> for checking the <a class="el" href="classroyale_1_1basic_string.html#ad48df31da4d8c5f4b82cb62113834dc3" title="Returns the actual size/length of the string (this is the used amount of slots in the allocated area)...">size()</a> itself) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of allocated slots for the element type which is bound to the string </dd></dl>

</div>
</div>
<a class="anchor" id="afc5a29b7c5f74bf1723fa97ea2de7df7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the begin of the string (first position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator to the begin of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a24cfa44a6bc4a10d434203816c0cf724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acd7d4401ebbd680902714012871f0111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end of the string (last position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator to the end of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a0f641a0d250e18d0e3e85002a2cc6b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a326406f8b4f3c430150441c8f1152377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the string (which are destroyed), leaving the container with a size of 0. </p>
<p>A reallocation is not performed and the string's capacity is destroyed (everything is freed). </p>

</div>
</div>
<a class="anchor" id="ab7454817195eb8cb6f2dd411b7efd709"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the reverse begin of the string (last position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator to the reverse begin of a string </dd></dl>

</div>
</div>
<a class="anchor" id="abbcac67ef73afbf048fc177cf703a848"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a98c7d58bf4cbeafaea2a81eefabe0c4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the reverse end of the string (first position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator to the reverse end of a string </dd></dl>

</div>
</div>
<a class="anchor" id="a99e2e9c374b0c64c18a972ea4b2cd35b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afef0a972c25f517b42bff5d4f22867bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a direct pointer to the memory array used internally by the string to store its owned elements. </p>
<p>Because elements in the string are guaranteed to be stored in contiguous storage locations in the same order as represented by the string, the pointer retrieved can be offset to access any element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>T* A pointer to the first element in the array used internally by the string. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9354acd2c34f8a317da08a3d51f3627"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a direct pointer to the memory array used internally by the string to store its owned elements. </p>
<p>Because elements in the string are guaranteed to be stored in contiguous storage locations in the same order as represented by the string, the pointer retrieved can be offset to access any element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>T* A pointer to the first element in the array used internally by the string. </dd></dl>

</div>
</div>
<a class="anchor" id="a61c32ccae743c4e5be4503a73e668921"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the string is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if the string is empty - otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a57c73e750806fc3e9c3b5b7861efba7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#ad3ef779e57c3071ff41933dc563070ed">iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the last position Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator to the end of the string. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6d7cfe2ddf92185b67ae87b61cd4aa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#a2d69ead94e19d4241199d25b12625ef4">const_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae802348bb773c01dc233ee599a3853f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename... Dummy, typename U , typename Type  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::enable_if&lt; std::is_same&lt;Type, char&gt;::value, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;Type&gt; &gt;::type <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromAny </td>
          <td>(</td>
          <td class="paramtype">const U&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to String from any Type. </p>

</div>
</div>
<a class="anchor" id="aa1e75298044d395dc5166b8c34c3f822"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename... Dummy, typename U , typename Type  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> std::enable_if&lt; std::is_same&lt;Type, wchar_t&gt;::value, <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;Type&gt; &gt;::type <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromAny </td>
          <td>(</td>
          <td class="paramtype">const U&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to WString from any Type. </p>

</div>
</div>
<a class="anchor" id="af20a3a242190219153949708d4f5bf2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromCArray </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given C-Style array to the string type used by the royale API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The C-Style array which should be converted to the royale API vector format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The royale API compliant string format </dd></dl>

</div>
</div>
<a class="anchor" id="a9e28ae9f19d0fcca35fdb3cc21424098"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to String from Int. </p>

</div>
</div>
<a class="anchor" id="af078b6af10bf0b399622770dd0392cbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromStdString </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given std::basic_string (STL) to the string type used by the royale API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The STL string which should be converted to the royale API vector format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The royale API compliant string format </dd></dl>

</div>
</div>
<a class="anchor" id="a6cd220dd6d384a1dd770ab7f175b2085"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt;T&gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::fromUInt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to String from unsigned Int. </p>

</div>
</div>
<a class="anchor" id="a8cb106ac4582f9b2714401e6d5faf070"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the string. </p>
<p>Calling this function on an empty string will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the first element in the string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the string is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b29e24293dbe4132c8ce6f188536d51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af809776b19cba7a749809095208e0aeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual size/length of the string (this is the used amount of slots in the allocated area) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of the actual used memory slots within the string </dd></dl>

</div>
</div>
<a class="anchor" id="a83eb98ed08a7881fc13df7bc3cb0590b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max_size of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The maximum length of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a4c155f20985f6a8c371c81862c559b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with an STL compliant string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An STL compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a1f12322ce9719d9f8f6cd5d148bbc1e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with a royale compliant string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An royale compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a20b558cbb9058a238d0985e38c8b6365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with a C-Style string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A C-style compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a6db1a86f363b6c6b9267352a9638e192"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two stirngs and returns the result (the second string is appended) The content of str is copied to the newly created element (NOTE: a deep copy is performed!). </p>
<p>This effectively increases the container size, which causes an automatic reallocation of the allocated storage space if -and only if- the new string size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a8526b68e24a8c7bc514288ef20030441"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b0bc4697cf123ff2c93ab3ae368e31c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40315b22baee696456acf7baa75643a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f5adfabbcfaa4dc8f33ece4bb424287"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the end of the string, after its current last element and returns the actual string element. </p>
<p>The content of str is copied to the new element (NOTE: a deep copy is performed!). This effectively increases the container size, which causes an automatic reallocation of the allocated storage space if -and only if- the new string size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a51c6d96f0b1ad3a1c28ab61ce6f52919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a76856ac5023d9a1d437607a74034ff00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ff8a7c5d2a0cfc6434221b818c5fd01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc01fd5b4ae4c87d37b71ba0976d90da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign another royale compliant string. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. This method copies all elements held by str into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a83b3431347eae688334fd7855d49382f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move elements to another royale compliant string. </p>
<p>Moves the elements of str into the container. The source container is reset to it's initial state which causes the allocation size to be reset (the allocated memory is moved) and the size counter to be reset. The data pointer is set to null.</p>
<p>Leaves the source object in a valid/initial state allowing somebody to reuse it for other purposes/data - like after executing <a class="el" href="classroyale_1_1basic_string.html#a326406f8b4f3c430150441c8f1152377" title="Removes all elements from the string (which are destroyed), leaving the container with a size of 0...">clear()</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A string object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="ac5faa84d758be2c15f49c3e6997dec6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the contents of an STL compliant string container by replacing container's current contents if necessary and modifying its size accordingly. </p>
<p>This method copies all elements held by str into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An STL compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a9f06c964b23013a298137907e97bcf1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the contents of an C-Style compliant string container by replacing container's current contents if necessary and modifying its size accordingly. </p>
<p>This method copies all elements held by str into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An C-Style compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a80b9d69ca31d55f25190faf2154f7677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a character to a royale compliant string container by replacing container's current contents and modifying its size accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The character to assign to the royale compliant string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basicString&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a7cc5379d5781fdcac8bcc499e4fe7773"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with an STL compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An STL compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a7ceff1b415565de95e42174eb9ca1f79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with a royale compliant string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An royale compliant string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a058d0e17bca7e293ebb7a9ece4d66b1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with a C-Style string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>An C-Style string of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a7695f287c0aee6474e3366f7f6f389f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element. </p>
<p>Returns a reference to the element at position index in the string container. A similar member function, <a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680" title="Access an element. ">at()</a>, has the same behavior as this operator function, except that <a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680" title="Access an element. ">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the string's storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the string </dd></dl>

</div>
</div>
<a class="anchor" id="aed81540a238ab1c8a56530f25b71f2c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access an element. </p>
<p>Returns a reference to the element at position index in the string container. A similar member function, <a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680" title="Access an element. ">at()</a>, has the same behavior as this operator function, except that <a class="el" href="classroyale_1_1basic_string.html#a5c509c3292d15c832190dd2e56157680" title="Access an element. ">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the string's storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the string </dd></dl>

</div>
</div>
<a class="anchor" id="aa93b4a2fe21f91028344afeb6a0ac568"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last element in the string, effectively reducing the container size by one. </p>
<p>The last element is destroyed by calling it's destructor; the size is reduced by one BUT there is no reallocation performed to resize the string to it's contents or to reduce the the string capacity by one. The allocated space remains the same. </p>

</div>
</div>
<a class="anchor" id="aff17794f88e1107b3a2e89e2bf0afde6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the end of the string, after its current last element. </p>
<p>The content of str is copied to the new element (NOTE: a deep copy is performed!). This effectively increases the container size, which causes an automatic reallocation of the allocated storage space if -and only if- the new string size surpasses the current string capacity. </p>

</div>
</div>
<a class="anchor" id="a7033616dddc037749c3cb6a8935fc88d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3009df262d03ec25bb308501c65f824"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50ed47847028e76ad19810cbe8dcfe2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sublen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="addc2dca452a65908b63266f21f4b29de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c18d78393183efce70780049078379a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b5ed99a88bf1c232068b4dc8ae6d413"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ace3a81a50aa0d0f3055caf3bc2d6de93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a76112d5334433ad4b9aa747382f78392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#ab33019164e938c2f20c1bde171360bc1">reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse begin (last position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator to the reverse begin of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a2e072592e1617bc3f0274ffd0f66dd9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a528e6466411c2143e01941af870ee1be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#ab33019164e938c2f20c1bde171360bc1">reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse end (first position) Calling this function on an empty string will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator to the reverse end of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a7788c014d94a0357bd52b5f4e3282862"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_definitions_8hpp.html#af83a0ad9d707a0bc5fe281b6e5c358a1">DllExport</a> <a class="el" href="classroyale_1_1basic_string.html#abc657ee1b591816a44dc8797b5292295">const_reverse_iterator</a> <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c953106f528c47f9f3e80d201a7f79d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the string to a higher allocation size and allocates the buffers. </p>
<p>Reserves any amount of free allocation slots (allocates the memory already) to be later used for the element-types bound to the given string vector.</p>
<p>If the given size to reserve is smaller than the already reserved space, then the function return immediately; otherwise the necessary memory allocation is performed and the size is extended to "size"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size (number of element-types) of elements that should be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9de316077ddd24a4cad3df61d155438b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the string to the given allocation size and allocates the buffers (it may shrink) </p>
<p>Creates any amount of elements (allocates the memory already) and moves the existing elements to these slots; afterwards the old space is dumped.</p>
<p>If the given newSize is smaller than the already used slots, the string will shrink. This means that all elements which are not covered within this capacity (the last ones) will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The amount of slots to remain in the string (might shrink or enlarge the string) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6552e9b0cbbf0be9a2594ee2a7afc7fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the string's allocation to it's size. </p>
<p>Changes the size of the allocated buffer to the string's size this may result in freeing unneeded memory allocation. </p>

</div>
</div>
<a class="anchor" id="ad48df31da4d8c5f4b82cb62113834dc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual size/length of the string (this is the used amount of slots in the allocated area) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of the actual used memory slots within the string </dd></dl>

</div>
</div>
<a class="anchor" id="a4026263abecc74c22fe58b57a00673a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::toStdString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::basic_string which might be used outside the library by the application for further processing. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string containing the items of the </dd></dl>

</div>
</div>
<a class="anchor" id="aea9e942a9588aa0e7e734e106ce30383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; T &gt; <a class="el" href="classroyale_1_1basic_string.html">royale::basicString</a>&lt; T &gt;::toStdString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::basic_string which might be used if the royale compliant string is a const. </p>
<dl class="section return"><dt>Returns</dt><dd>std::basic_string containing the items of the </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a454da36bff6bdbad033ccb9da2cc400e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classroyale_1_1basic_string.html">basicString</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_string_8hpp_source.html">String.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 23 2015 16:14:29 for Royale by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
